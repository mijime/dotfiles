#!/bin/bash

function find-peco-() {
    local eval_prog
    local find_regx
    local peco_result

    eval_prog=${1:-#} && shift
    find_regx=${*:-.}

    peco_result=$(find $find_regx | peco)
    [[ 0 -eq $? && ! -z "$peco_result" ]] && { echo "$eval_prog $peco_result"; eval "$eval_prog" "$peco_result"; }
}

function _history-peco() {
    local peco_result
    peco_result=$(history | sort -r | peco --query "$(_buffer)" | sed 's%^[ 0-9/:]*%%g')

    _set_readline $peco_result
}

function _git-status-peco() {
    local peco_result
    peco_result=$(git status -s 2> /dev/null | peco 2> /dev/null | awk -v readline="$(_buffer)" '
        readline!="" { print readline, $2; next }
        $1~/\?/ { print "git add", $2; next }
        $1~/M/ { print "git diff", $2; next }
        $1~/D/ { print "git checkout", $2; next }
        $1~/A/ { print "git rm --cached", $2; next }
        { print $2; next } ')

    _set_readline $peco_result
}

function _buffer() {
    case $SHELL in
        *zsh) echo $BUFFER;;
        *bash) echo $READLINE_LINE;;
    esac
}

function _set_readline() {
    case $SHELL in
        *zsh)
            BUFFER="$*"
            CURSOR=${#BUFFER}
            zle reset-prompt
            ;;
        *bash)
            READLINE_LINE="$*"
            READLINE_POINT=${#READLINE_LINE}
            ;;
    esac
}

if which peco 2> /dev/null > /dev/null; then
case $SHELL in
    *zsh)
        zle -N history-peco _history-peco
        bindkey '^r' history-peco
        zle -N git-status-peco _git-status-peco
        bindkey '^g' git-status-peco
    ;;
    *bash)
        bind -x '"\C-r": _history-peco'
        bind -x '"\C-g": _git-status-peco'
    ;;
esac
fi
